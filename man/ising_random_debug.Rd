% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ising_random.R
\name{ising_random_debug}
\alias{ising_random_debug}
\title{Draw and plot the creation of a random Ising graph.}
\usage{
ising_random_debug(number_nodes, p, set_seed = F, plot = T,
                   procedure = 1, debug = F, feedback = F)
}
\arguments{
\item{number_nodes}{(int scalar) Number of nodes.}

\item{p}{(double scalar) Probability of obtaining an edge in the network.}

\item{set_seed}{(boolean scalar | int scalar) Should the sampling occur under seeding? Defaults to FALSE.}

\item{plot}{(boolean scalar) Should the unweighted and weighted graphs be plotted? Defaults to TRUE.}

\item{procedure}{(int scalar) Should the binary sampling occur for the edges or the interaction parameters?
Values: 1 for edges or 2 for interaction parameters. Defaults to 1.}

\item{debug}{(boolean scalar) Should the feedback regarding the number of edges be included in the output? Defaults to FALSE.}

\item{Feedback}{(boolean scalar) Should the feedback be displayed to the console? Defaults to FALSE.}
}
\value{
A list containing the sampled data, the unweighted graph and the weighted graph. If \code{debug} is set
                    to TRUE additional information is included.
}
\description{
This function is used to illustrate how the random graphs for the Ising model are sampled.
}
\details{
First, we sample a binary dataset N ^ 2, where N is the number of nodes in the network. The
probability of sampling a value of 1 is equal to the probability specified by the function
argument p, and the probability of sampling a 0 is 1 - p.

Next, we create a new symmetrical matrix from the sampled dataset and set its main diagonal
to 0. This represents the unweighted graph.

Next, we create an weighted graph from the unweighted graph. To do so we generate a matrix
with values from the normal distribution (M = 0, SD = 1) with the same number of columns
and rows and the unweighted matrix. We also make this matrix symmetrical (i.e., no need to
set the main diagonal to 0). Now, the weighted random graph is obtained by multiplying
the unweighted graph by the symmetrical random matrix.

My two cents on this procedure. I think that we end up with a biased number of edges in
the unweighted graph. The reason for this may have to do with the way we sample the binary
data in the first place. Say we specified p = .8 for a network with 10 nodes, then, we
expect our binary sample to show close to 80% of edges (i.e., the sum of all cells ~80 ).
However, these edges are placed at random in the matrix (i.e., this is not a symmetrical
matrix). Thus, when we transform the matrix to be symmetrical, we end up with more edges
than we originally requested (i.e., 80% because of the p = .8).

I am not sure if this is a problem or not. But would the following make sense?
Instead of sampling a binary dataset of N ^ 2 with a p = .8 that represents the edges in
the network, we sample the interaction parameters. Specifically, we first determine the
number of interaction parameters as N * (N - 1) / 2, then we sample a binary vector of
the same size as the number if interaction parameters with p = .8. Next, we use this
vector to build the unweighted graph, meaning that both the upper and the lower triangle
of the matrix are set to this vector. The difference being that both triangles hold values
sampled with the same probability.
}
